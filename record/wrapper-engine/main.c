/*
 * Copyright (c) 1999-May 2, 2014: Jeffrey Vetter (vetter3@llnl.gov)
 * Copyright (c) of subsequent modifications of this code:
 * Frederic Suter, CNRS / IN2P3 Computing Center <fsuter@cc.in2p3.fr>
 * Henri Casanova, ICS Dept., University of Hawai`i at Manoa <henric@hawaii.edu>

 * The license of the original code is unknown. Modifications are made
 * under the terms of the GNU LGPL license.
 */

#ifndef lint
static char *rcsid =
  "$Header: /home/cvs/cvs/xwu3/ScalaTraceV2/record/wrapper-engine/main.c,v 1.1 2012/04/02 05:12:10 xwu3 Exp $";
#endif

#include <assert.h>
#include <stdlib.h>
#include "wrapper.h"

/* parser generated by yacc */
 extern int yyparse();

char *nameStr = NULL;
int tag, BASE_OPCODE;

FILE *wrapperFile = NULL;    /* Fortran, C and generic wrappers */
FILE *opsFile = NULL;        /* enums for mpi operations */
FILE *structFile = NULL;     /* umpi_mpi_lookup_t definition */
FILE *lookupFile = NULL;     /* umpi_mpi_lookup declaration */
FILE *paramFile = NULL;      /* umpi_mpi_param_t definition */
FILE *mgrverifyFile = NULL;  /* mgrverify_op function definitions */
FILE *mgrverifyHFile = NULL; /* mgrverify_op function declarations */
FILE *outverifyFile = NULL;  /* outverify_op function definitions */
FILE *outverifyHFile = NULL; /* outverify_op function declarations */
FILE *printFile = NULL;      /* print_op function definitions */
FILE *printHFile = NULL;     /* print_op function declarations */
FILE *packFile = NULL;       /* pack_op function definitions */
FILE *packHFile = NULL;      /* pack_op function declarations */
FILE *unpackFile = NULL;     /* unpack_op function definitions */
FILE *unpackHFile = NULL;    /* unpack_op function declarations */
FILE *freeFile = NULL;       /* free_op function definitions */
FILE *freeHFile = NULL;      /* free_op function declarations */
FILE *copyFile = NULL;       /* copy_op function definitions */
FILE *copyHFile = NULL;      /* copy_op function declarations */
FILE *replayHFile = NULL;      /* replay_op function declarations */
FILE *replayFile = NULL;      /* replay_op function declarations */
FILE *posixWrapFile = NULL;  /* Posix function wrappers */
void *paramKeywords = NULL;

void
param_print_name (const void *n1, VISIT order, int level)
{
  char *s1 = (*((paramNode_t **) n1))->name;
  char *t1 = (*((paramNode_t **) n1))->type;
  switch (order)
    {
    case postorder:
    case leaf:
      fprintf (paramFile, "\t%s %s;\n", t1, s1);
      break;
    default:
      break;
    }
  return;
}

void
SaveParamHeader (char *name)
{
  //  char buf[256];
  //  sprintf (buf, "umpi_%s_params.h", name);
  //  paramFile = fopen (buf, "w");
  fprintf (paramFile,
	   "/* Parameter header file */\n"
	   "\n"
	   "/* !!!!! Automatically generated by wrapper generator !!!!! */\n"
	   "\n"
       "#include <mpi.h>\n"
	   "\n"
       "typedef int MPI_Handle_type;\n"   /* NOTE: These are hacks for MPI_Handles. Will this work in all cases? */
       "typedef int MPI_Handle_enum;\n"
	   "\n"
	   "#ifndef _UMPI_%s_PARAM_H\n"
	   "#define _UMPI_%s_PARAM_H 1\n"
	   "\n" "\n" "typedef struct _umpi_%s_param {\n", name, name, name);

  twalk (paramKeywords, param_print_name);

  fprintf (paramFile, "} umpi_%s_param_t;\n" "\n" "#endif\n" "\n" "\n", name);

  fclose (paramFile);

  return;
}

void
OpenFiles ()
{
  char buf[128];

  sprintf (buf, "umpi_%s_params.h", nameStr);
  paramFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s.c", nameStr);
  wrapperFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s.h", nameStr);
  structFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_ops.h", nameStr);
  opsFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_lookup.c", nameStr);
  lookupFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_mgr_verify.c", nameStr);
  mgrverifyFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_mgr_verify.h", nameStr);
  mgrverifyHFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_outfielder_verify.c", nameStr);
  outverifyFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_outfielder_verify.h", nameStr);
  outverifyHFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_print_ops.c", nameStr);
  printFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_print_ops.h", nameStr);
  printHFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_pack_ops.c", nameStr);
  packFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_pack_ops.h", nameStr);
  packHFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_unpack_ops.c", nameStr);
  unpackFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_unpack_ops.h", nameStr);
  unpackHFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_free_ops.c", nameStr);
  freeFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_free_ops.h", nameStr);
  freeHFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_copy_ops.c", nameStr);
  copyFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_copy_ops.h", nameStr);
  copyHFile = fopen (buf, "w");

  sprintf (buf, "umpi_posix_wrapper.c");
  posixWrapFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_replay_ops.h", nameStr);
  replayHFile = fopen (buf, "w");

  sprintf (buf, "umpi_%s_replay_ops.c", nameStr);
  replayFile = fopen (buf, "w");

 /* wrapper file */
  fprintf (wrapperFile,
	   "/* Umpire wrappers for all traceable MPI functions */\n\n"
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "#include <setjmp.h>\n"
	   "#include <errno.h>\n"
	   "#include \"umpi_internal.h\"\n\n"
     "/* This is a hack to avoid warnings with MPICH, which doesn't declare this function.\n"
     "   If we don't declare this, return type isimplicit int, and we get warnings about casting.\n"
     "   ints to pointers on systems where sizeof(void*) != sizeof(int). */\n"
     "extern void* MPIR_ToPointer(int);\n\n"
     "#ifndef NO_REENTRY_GUARD\n"
     "/* This is a guard against MPI implementations that make raw MPI calls within MPI calls.\n"
     "   If you don't want to pay for this, #define NO_REENTRY_GUARD. */\n"
     "static int in_wrapper=0;\n"
     "#endif /* NO_REENTRY_GUARD */\n\n"
     "#include \"umpi_pc.h\"\n"
     "\n#include \"Event.h\"\n" //added by Xing
     "#include \"Trace.h\"\n" //added by Xing
     "#include \"PtrHandler.h\"\n" //added by Xing
     "#include \"ReqHandler.h\"\n" //added by Xing
     "#include \"radix_tree.h\"\n" //added by Xing
     "#include \"mpi_util.h\"\n\n" //added by Xing
  );

  /* struct file */
  fprintf (structFile,
	   "/* Umpire lookup table struct header file */\n\n"
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n\n"
	   "#ifndef _UMPI_MPI_H\n#define _UMPI_MPI_H\n\n"
     "\n#include\"umpi_%s_ops.h\"\n", nameStr
     );

  /* ops file */
  fprintf (opsFile,
	   "/* Umpire lookup table ops header file */\n\n"
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n\n"
	   "#ifndef _UMPI_MPI_OPS_H\n#define _UMPI_MPI_OPS_H\n\n"
     "typedef enum {\n"
     "umpi_MPI_op_min,\n"
     );

  /* lookup file */
  fprintf (lookupFile,
	   "/* Umpire lookup table for all traceable MPI functions */\n\n"
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n#include \"umpi_internal.h\"\n"
	   "\n\n"
	   "/* WARNING: This is a READ-ONLY lookup table. The information\n"
	   "   here maps directly to the source code generated by the wrapper\n"
	   "   engine. Non-coherence is a BAD thing!\n */\n");
  fprintf (lookupFile, "\n" "umpi_%s_lookup_t umpi_%s_lookup [UMPI_OPCODE_COUNT] = {" "\n",
	   nameStr, nameStr);

  /* mgrverify file */
  fprintf (mgrverifyFile,
	   "/* Umpire verification code for mgr */\n\n"
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n#include \"umpi_internal.h\"\n\n");

  /* mgrverify header file */
  fprintf (mgrverifyHFile,
	   "/* Umpire verification code for mgr header file */\n\n"
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n\n"
	   "#ifndef _UMPI_MPI_MGR_VERIFY_H\n"
	   "#define _UMPI_MPI_MGR_VERIFY_H\n\n\n");

  /* outverify file */
  fprintf (outverifyFile,
	   "/* Umpire verification code for outfielder */\n\n"
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n#include \"umpi_internal.h\"\n\n");

  /* outverify header file */
  fprintf (outverifyHFile,
	   "/* Umpire verification code for outfielder header file */\n\n"
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n\n"
	   "#ifndef _UMPI_MPI_OUTFIELDER_VERIFY_H\n"
	   "#define _UMPI_MPI_OUTFIELDER_VERIFY_H\n\n\n");

  /* print file */
  fprintf (printFile,
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n#ifndef __STDC_FORMAT_MACROS"
	   "\n#define __STDC_FORMAT_MACROS"
	   "\n#endif"
	   "\n#include <stdint.h>"
	   "\n#include <inttypes.h>"
       "\n#include \"umpi_internal.h\"\n"
	   "\n#include \"Event.h\""
	   "\n#include \"mpi_util.h\"\n"
     "\n");

  /* print header file */
  fprintf (printHFile,
	   "/* Umpire code for printing umpi_ops header file */\n\n"
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n\n"
	   "#ifndef _UMPI_MPI_PRINT_OP_H\n"
	   "#define _UMPI_MPI_PRINT_OP_H\n\n\n");

  /* pack op file */
  fprintf (packFile,
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n#include \"umpi_internal.h\"\n\n");

  /* pack op header file */
  fprintf (packHFile,
	   "/* Umpire code for packing umpi_ops header file */\n\n"
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n\n"
	   "#ifndef _UMPI_MPI_PACK_OP_H\n"
	   "#define _UMPI_MPI_PACK_OP_H\n\n\n");

  /* unpack op file */
  fprintf (unpackFile,
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n#include \"umpi_internal.h\"\n\n");

  /* unpack op header file */
  fprintf (unpackHFile,
	   "/* Umpire code for unpacking umpi_ops header file */\n\n"
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n\n"
	   "#ifndef _UMPI_MPI_UNPACK_OP_H\n"
	   "#define _UMPI_MPI_UNPACK_OP_H\n\n\n"
	   "int umpi_generic_unpack (umpi_op_t*op,char *buf);\n\n\n");

  /* free op file */
  fprintf (freeFile,
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n#include \"umpi_internal.h\"\n\n");

  /* free op header file */
  fprintf (freeHFile,
	   "/* Umpire code for freeing umpi_ops header file */\n\n"
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n\n"
	   "#ifndef _UMPI_MPI_FREE_OP_H\n"
	   "#define _UMPI_MPI_FREE_OP_H\n\n\n");

  /* copy op file */
  fprintf (copyFile,
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n#include \"umpi_internal.h\"\n\n");

  /* copy op header file */
  fprintf (copyHFile,
	   "/* Umpire code for copying umpi_ops header file */\n\n"
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n\n"
	   "#ifndef _UMPI_MPI_COPY_OP_H\n"
	   "#define _UMPI_MPI_COPY_OP_H\n\n\n");

  /* replay op header file */
  fprintf (replayHFile,
	   "/* Umpire code for replaying umpi_ops header file */\n\n"
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n\n"
	   "#ifndef _UMPI_MPI_REPLAY_OP_H\n"
	   "#define _UMPI_MPI_REPLAY_OP_H\n\n\n");

  /* replay op file */
  fprintf (replayFile,
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "\n#include \"umpi_internal.h\"\n\n");

  /* posix wrapper file */
  fprintf (posixWrapFile,
	   "/* Umpire wrappers for all traceable POSIX functions */\n\n"
	   "/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */\n\n"
	   "#include <setjmp.h>\n"
	   "#include <errno.h>\n"
           "#include <sys/types.h>\n"
           "#include <stdio.h>\n" 
	   "#include \"umpi_internal.h\"\n\n"
           "#include \"umpi_pc.h\"\n\n"
           "extern int is_mpi_inited;\n"
  );

  return;
}

extern char union_buf[];
extern void attr_action_print_name_for_struct (const void *i_node,
					       VISIT order, int level);

extern int lookupCount;

void
CloseFiles ()
{
  //  fprintf (wrapperFile, "\n" "\n/*eof*/\n");
  //  fclose (wrapperFile);

  fprintf (opsFile,
     "umpi_MPI_op_max\n"
	   "\n} MPI_Op_t;\n\n"
	   "\n#endif\n" "\n/*eof*/\n"
     );

  fprintf (structFile,
	   "typedef struct _umpi_mpi_lookup_t\n{\n"
	   "char * name;\n" "int id;\n");

  twalk (AL, attr_action_print_name_for_struct);

  fprintf (structFile,
	   "\nint (*vcode_g_pre)(umpi_op_t * op);\n"
	   "int (*vcode_g_post)(umpi_op_t * op);\n"
	   "\nint (*vcode_l_pre)(umpi_op_t * op);\n"
	   "int (*vcode_l_post)(umpi_op_t * op);\n"
	   "void (*print_op)(umpi_op_t * op, char *buf);\n"
	   "int (*pack_op)(umpi_op_t * op, char *buf, int maxlen);\n"
	   "int (*pack_op_size)(umpi_op_t * op);\n"
	   "int (*unpack_op)(umpi_op_t * op, char *buf);\n"
	   "void (*free_op)(umpi_op_t * op);\n"
	   "void (*copy_op)(umpi_op_t * op, umpi_op_t * newop);\n"
	   "int (*type_match_check)(umpi_matching_op_t * m_op1, umpi_matching_op_t * m_op2, int retain_type_res);\n"
	   "int (*local_collective_type_check)(umpi_op_t * op, int lrank);\n"
	   "int (*collective_type_res)(umpi_op_t * op, umpi_matching_op_t * m_op);\n"
           "void (*replay_op)(void * node);\n"
	   "\n} umpi_mpi_lookup_t;\n\n"
	   "#define UMPI_BASE_OPCODE %d\n"
	   "#define UMPI_OPCODE_COUNT %d\n"
	   "\n#endif\n" "\n/*eof*/\n",
	   BASE_OPCODE, lookupCount);

  /* if this isn't true than either we incremented tag without */
  /* creating a lookup table entry or vice versa; either way */
  /* we can no longer assume that code - BASE_OPCODE is the */
  /* index of the op in the lookup table... */
  assert ((tag - BASE_OPCODE) == lookupCount);

  fclose (structFile);

  fclose (opsFile);

  fprintf (wrapperFile, "\n" "\n/*eof*/\n");
  fclose (wrapperFile);

  fprintf (lookupFile, "\n" "};\n/*eof*/\n");
  fclose (lookupFile);

  fprintf (mgrverifyFile, "\n" "\n/*eof*/\n");
  fclose (mgrverifyFile);

  fprintf (mgrverifyHFile, "\n\n#endif\n" "\n/*eof*/\n");
  fclose (mgrverifyHFile);

  fprintf (outverifyFile, "\n" "\n/*eof*/\n");
  fclose (outverifyFile);

  fprintf (outverifyHFile, "\n\n#endif\n" "\n/*eof*/\n");
  fclose (outverifyHFile);

  fprintf (printFile, "\n" "\n/*eof*/\n");
  fclose (printFile);

  fprintf (printHFile, "\n\n#endif\n" "\n/*eof*/\n");
  fclose (printHFile);

  fprintf (packFile, "\n" "\n/*eof*/\n");
  fclose (packFile);

  fprintf (packHFile, "\n\n#endif\n" "\n/*eof*/\n");
  fclose (packHFile);

  /* define generic unpack function */
  fprintf (unpackFile,
	   "int umpi_%s_generic_unpack (umpi_op_t*op,char*buf,int sender)\n{"
	   "\numpi_%s_lookup_t *lookup;"
	   "\nunsigned index;"
     "\nint temp, packed_size, oversized;\n\n"
	   "assert(op);\n"
	   "assert(buf);\n\n",
	   nameStr, nameStr);

  /* unpack header */
  fprintf (unpackFile, 
	   "bcopy (buf, &temp, sizeof(int));\n"
	   "assert(temp == UMPI_START_PACKED_OP);\n"
	   "index = sizeof(int);\n\n");
  fprintf (unpackFile, 
	   "bcopy (&buf[index], &packed_size, sizeof(int));\n"
	   "index += sizeof(int);\n\n");

  /* handle oversized op... */
  fprintf (unpackFile, 
	   "oversized = (packed_size > UMPI_MAX_MSG_BYTES);\n"
	   "if (oversized) {\n"
	   "bcopy (&buf[index], &temp, sizeof(int));\n"
	   "assert(temp == UMPI_END_SPLIT_PACKED_OP);\n"
	   "buf = (char *) malloc (sizeof(char) * packed_size);\n"
	   "assert(buf);\n"
	   "//umpi_mgr_large_op_recv(buf, packed_size, sender);\n");

  /* unpack header again when oversized*/
  fprintf (unpackFile, 
	   "bcopy (buf, &temp, sizeof(int));\n"
	   "assert(temp == UMPI_START_SPLIT_PACKED_OP);\n"
	   "index = sizeof(int);\n\n");
  fprintf (unpackFile, 
	   "bcopy (&buf[index], &temp, sizeof(int));\n"
	   "index += sizeof(int);\n"
	   "assert(temp == packed_size);\n}\n\n");

  /* check trailer */
  fprintf (unpackFile, 
	   "bcopy (&buf[packed_size - sizeof(int)], &temp, sizeof(int));\n"
	   "assert(temp == UMPI_END_PACKED_OP);\n\n");

  /* unpack general op info: op, order, rank, pc and seq_num */
  fprintf (unpackFile, 
	   "bcopy (&buf[index], &(op->op), sizeof(op->op));\n"
	   "index += sizeof(op->op);\n\n");
  fprintf (unpackFile, 
	   "bcopy (&buf[index], &(op->order), sizeof(op->order));\n"
	   "index += sizeof(op->order);\n\n");
  fprintf (unpackFile, 
	   "bcopy (&buf[index], &(op->rank), sizeof(op->rank));\n"
	   "index += sizeof(op->rank);\n\n");
  fprintf (unpackFile, 
	   "bcopy (&buf[index], &(op->pc), sizeof(op->pc));\n"
	   "index += sizeof(op->pc);\n\n");
  fprintf (unpackFile, 
	   "bcopy (&buf[index], &(op->seq_num), sizeof(op->seq_num));\n"
	   "index += sizeof(op->seq_num);\n\n");

  /* unpack op-specific part (e.g., params) */
  fprintf (unpackFile, 
	   "lookup = get_struct_by_opcode (op->op);\n"
	   "index += lookup->unpack_op (op, &buf[index]);\n\n");

  /* clean up from oversized ops... */
  fprintf (unpackFile, 
	   "if (oversized) free (buf);\n\n");

  /* finish up generic unpack definition... */
  fprintf (unpackFile, 
	   "assert (index == (packed_size - sizeof(int)));\n\n"
	   "return packed_size;\n"
	   "} /* umpi_unpack_generic_op */\n\n\n");

  fprintf (unpackFile, "\n" "\n/*eof*/\n");
  fclose (unpackFile);

  fprintf (unpackHFile, "\n\n#endif\n" "\n/*eof*/\n");
  fclose (unpackHFile);

  fprintf (freeFile, "\n" "\n/*eof*/\n");
  fclose (freeFile);

  fprintf (freeHFile, "\n\n#endif\n" "\n/*eof*/\n");
  fclose (freeHFile);

  fprintf (copyFile, "\n" "\n/*eof*/\n");
  fclose (copyFile);

  fprintf (copyHFile, "\n\n#endif\n" "\n/*eof*/\n");
  fclose (copyHFile);

  fprintf (replayHFile, "\n\n#endif\n" "\n/*eof*/\n");
  fclose (replayHFile);

  fprintf (replayFile, "\n" "\n/*eof*/\n");
  fclose (replayFile);

  fprintf (posixWrapFile, "\n" "\n/*eof*/\n");
  fclose (posixWrapFile);

  return;
}

int
main (int ac, char **av)
{
  if (ac != 3)
    {
      printf("Usage: wgen.exe <name> <tag>\n");
      printf("Version:\n%s\n", rcsid);
      exit (1);
    }
  else
    {
      nameStr = av[1];
      BASE_OPCODE = tag = atoi (av[2]);
    }
  OpenFiles ();
  yyparse ();
  fprintf(stderr,"\n");
  CloseFiles ();
  SaveParamHeader (nameStr);
  return 0;
}

/* EOF */
